.. include:: ../../references.txt

.. _pig-009:

***********************
PIG 9 - Event simulator
***********************

* Author: Fabio Pintore, Andrea Giuliani, Axel Donath
* Created: May 03, 2019
* Accepted: 
* Status: 
* Discussion:  

Introduction
============

An event simulator of gamma events is of high importance in exploiting the potentiality of the future Cherenkov Telescope
Array (CTA). It will allows us to simulate sources with different spectral and morphological properties adn e.g. investigating
the best configurations for each type of objects and the expected performance of CTA on this data. An event simulator is also listed
as a requirement for the future CTA Science Tools. For this reason, we propose to implement a framework for event simulation
in Gammapy. Based on finely binned input maps, containing the predicted number of counts for a given source with a defined
morphological and spectral model it samples events using the inverse cumulative distribution (Inverse CDF). In addition
a light curve model can be taken into account. Then the proposed simulator will be able to apply the PSF and energy dispersion
to each sampled event. Furthermore, the sampler will include the simulation of background events, again based on finely
binned maps. The final output of the simulator is a stacked event list with source and background events for a given
observation.


A working prototype of the event sample can be found at this URL: https://github.com/fabiopintore/notebooks-public/blob/master/gammapy-event-sampling/prototype.ipynb

Proposal
========

We propose to introduce the following classes to implement the event simulation framework in Gammapy.

InverseCDFSampler
=================

The first building block of the event simulator is a class that samples from a given probability function (PSF). For this
we use the inverse CDF sampling method (https://en.wikipedia.org/wiki/Inverse_transform_sampling). In more detail, it
calculates the cumulative distribution function and, once a set of random numbers is determined, it samples a set of events.
The proposed implementation follows closely what is described here https://stackoverflow.com/questions/21100716/fast-arbitrary-distribution-random-sampling/21101584#21101584:

The basic design of the class is as following:

.. code::

    from gammapy.utils.distributions import InverseCDFSampler

    pdf = np.array()
    cdf_sampler = InverseCDFSampler(pdf=pdf, random_state=random_state)

Where the `gammapy.utils.random.get_random_state` method is used. The class implements mainly the `.sample()` method
to draw samples from the given pdf:

.. code::

    cdf_sampler = InverseCDFSampler()
    samples = cdf_sampler.sample(size=100)

The returned object is a `np.ndarray` containing the sampled indices.

In addition the `InverseCDFSampler` should have the possibility to sample only along a given axis of the PDF. This features is
required to handle sampling of multiple PDFs a the same time to avoid a Python loop over the PDFs. This will be supported
by specifying the `axis` argument:

.. code::

    cdf_sampler = InverseCDFSampler(pdf=pdfs, axis=0)
    samples = cdf_sampler.sample(size=1)


The `InverseCDFSampler` could possibly implement a few helper functions to plot the CDF or PDF. The `InverseCDFSampler`
class will replace the current `GeneralRandom` and `GeneralRandomArray` classes in `gammapy.utils.distributions`.
Possibly the `InverseCDFSampler` needs a to support transforming PDFs e.g. log transformations of power-laws to maintain
accuracy. The need for this is unclear.


MapEventSampler
===============

To support sampling from the predicted number of counts maps for source as well as background maps, we propose to
introduce a `MapEventSampler` class. The responsibility of this class is to handle the physical coordinate transformations,
time dependence of the model, output data structures and sampling of the total number of observed events.

Starting from a predicted number of counts map (e.g. computed by the `MapEvaluator`):

.. code::

    src = SkyModel()
    evaluator = MapEvaluator(src, exposure, psf=None, edisp=None)
    npred_map = evaluator.compute_npred()

The `MapEventSampler` takes this map and a lightcurve model as an input and allows to sample from it with the `.sample()`
method:

.. code::

    lightcurve = LightCurveTableModel() # or PhaseCurveTableModel()
    src_sampler = MapEventSampler(npred_map, lightcurve, t_min=, t_max=)

    # draw total number of events
    n_events = src_sampler.npred_total()

    # draw events as an astropy table
    events_src = map_sampler.sample()

If no lightcurve is provided a constant rate can be assumed e.g. for background models:

.. code::

    bkg_map = BackgroundModel().map
    bkg_sampler = MapEventSampler(bkg_map, t_min=, t_max=)
    events_bkg = bkg_sample.sample()


It remains to answer the question what to do when the source lightcurve is shorter than the total exposure time: do we
repeat the temporal information or do we just consider the remaining time as a flat lightcurve?


IRFMapSampler
=============

The handle correctly the spatially varying IRFs, we propose to introduce an `IRFMapSampler` class. Based on the `PSFMap`
and `EDispMap` as an input it interpolates the "correct" IRF at the position of a given event and applies it. In more detail
the class will calculate the psf and the energy dispersion for each event true position and true energy. The reconstructed
energies and positions are then appended to the event list. The IRFs are assumed to be constant and not time-dependent.
The time dependency will be handled higher level, by a loop over good time-intervals. The class would be used as following:

.. code::

    events = vstack([events_src_1, events_src_2, ..., events_src_N])
    irf_sampler = IRFMapSampler(psf_map, edisp_map)

    events = irf_sampler.sample_psf(events)
    events = irf_sampler.sample_edisp(events)

Alternatively the IRFs could be applied per model component and be handled in the `MapEventSampler`. However in this case
the IRFs would not be applied correctly for e.g. very extended sources, because the IRF changes over region of the source.
If we find the approach with the `IRFMapSampler` to be not performant enough or problematic in memory use, it can be still
used as a simple fallback solution.

MapDatasetEventSampler?
=======================

To combine the `MapEventSampler` and `IRFMapSampler` objects we finally propose to introduce a `MapDatasetEventSampler`,
which executes the sampling from all source components, applies the IRFs, samples from the background model and returns
a stacked, combined event list.

This is the proposed high level API:

.. code::
    
    dataset_sampler = MapDatasetEventSampler(dataset)
    events = dataset_sampler.sample()

This requires to add `t_min` and `t_max` information to `MapDataset` or maybe a `MapDataset.gti` attribute, defining the
GTI for the given dataset. In addition it also requires to add a lightcurve model to the `SkyModel`.

More detailed:

.. code::

    events = []

    # sample from source components
    for evaluator in dataset._evaluators:
        evaluator.psf = None?
        evaluator.edisp = None?
        npred = evaluator.compute_npred()

        sampler = MapEventSampler(npred)

        # set an ID for the source component?
        
        events.append(sampler.sample())

    events_stacked = vstack(events)

    # apply IRFs
    irf_sampler = IRFSampler(events_stacked, dataset.psf_map, dataset.edisp_map)
    events_reco = irf_sampler.sample()

    # sample from background
    bkg_sampler = MapEventSampler(dataset.background_model.map)
    events_bkg = bkg_sampler.sample()

    events_total = vstack([events_reco, event_bkg])


Simulating multiple observations
================================
The question of simulating mutiple observations from e.g. an `ObservationTable` or `GTI` object as it is needed for
simulating data for the CTA data challenge is not addressed in this PIG.



Alternatives
============
Instead of introducing a parallel class structure of sampler objects once could introduce `.sample()` methods on the
existing related classes in Gammapy:

- `events_src = MapEvaluator.sample()` to sample from a source model
- `events = EdispMap.sample(events=)` to apply the energy dispersion
- `events = PsfMap.sample(events=)` to appy the PSF
- `events = MapDataset.sample()` to combine all together.

This has the advantage of a smaller API, but is less flexible.


Binned Simulation
-----------------
As an alternative approach one could also use binned simulations by fluctuating the number of counts in each bin of a
given map or spectrum. This is not a real alternative, but could be offered in addition and used depending on the use case.


List of proposed pull requests
==============================

This is a proposal for a list of pull requests implementing the proposed changes, ordered by priority:

1. Rename `gammapy.utils.distributions` to `gammapy.utils.random` and move the current `gammapy.utils.random` there (v0.12).
2. Remove the currently unused `GeneralRandomArray` class (v0.12)
3. Implement the InverseCDFSampler in `gammapy.utils.random` in `inverse_cdf.py` and add tests.
4. Remove the current `GeneralRandom` class and adapt `gammapy.astro.population.simulate` accordingly.
5. Implement `MapEventSampler` class ... (v0.13, v0.14)?
6. Implement IRFSampler into gammapy. ... (v0.13, v0.14)?
7. Implement IRFSampler into gammapy. ... (v0.13, v0.14)?

Decision
========






