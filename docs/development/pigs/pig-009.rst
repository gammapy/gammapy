.. include:: ../../references.txt

.. _pig-009:

***********************
PIG 9 - Event Sampler
***********************

* Author: Fabio Pintore, Andrea Giuliani, Axel Donath
* Created: May 03, 2019
* Accepted: 
* Status: 
* Discussion:  

Abstract
============

An event sampler of gamma events is of high importance in exploiting the potentiality 
of the future Cherenkov Telescope Array (CTA). It will allows us to simulate sources 
with different spectral and morphological properties adn e.g. investigating the best 
configurations for each type of objects and the expected performance of CTA on this 
data. An event sampler is also listed as a requirement for the future CTA Science 
Tools. For this reason, we propose to implement a framework for event simulation in 
Gammapy. Based on finely binned input maps, containing the predicted number of counts
for a given source with a defined morphological and spectral model, it samples events 
using the inverse cumulative distribution (Inverse CDF). 

This approach is different from the one adopted by the FERMI tools and the CTOOLS/Ctobssim, 
as they make use of the rejection sampling method (see an example here _gammalib).
Generally, when facing with discrete distribution, the Inverse CDF method is very efficient
although there are cases where it may be less precise. Instead, the rejection sampling
method can be highly precise but it is less efficient (for example should the distribution
have narrow features). Implenting the latter in Gammapy would be problematic at this 
moment, as in Python it would neeed for loops on each sampled model, implying a very 
slow approach. However, we note also that the Inverse CDF method is used by `ASTRIsim` 
(_astrisim), the simulator of the AGILE collaboration. 
Furthermore, it is important to mention that Gammapy already implements a preliminary 
binned simulation, for example for spectra or 3D-simulations (e.g. _spec and _three-D).

The proposed simulator not only samples the spectral and morphology properties, but it 
will also take into account the possibility to sample a light curve model. Then the proposed 
event sampler will be able to apply the PSF and energy dispersion to each sampled event. 
Furthermore, the sampler will include the simulation of background events, again based 
on finely binned maps. The final output of the sampler is a stacked event list with 
source and background events for a given observation.

A working prototype of the event sample can be found in Prototype_ .

Proposal
========

We propose to introduce the following classes to implement the event sampler framework
in Gammapy.

InverseCDFSampler
=================

The first building block of the event sampler is a class that samples from a given 
probability function (PSF). For this we use the inverse CDF sampling method (inverseCDF_). 
The proposed implementation follows closely what is described here_:

The basic design of the class is as following:

.. code::

    from gammapy.utils.distributions import InverseCDFSampler

    pdf = np.array()
    cdf_sampler = InverseCDFSampler(pdf=pdf, random_state=random_state)

Where the `gammapy.utils.random.get_random_state` method is used. The class 
implements mainly the `.sample()` method to draw samples from the given pdf:

.. code::

    cdf_sampler = InverseCDFSampler()
    samples = cdf_sampler.sample(size=100)

The returned object is a `np.ndarray` containing the sampled indices.

In addition the `InverseCDFSampler` should have the possibility to sample only 
along a given axis of the PDF. This features is required to handle sampling of 
multiple PDFs at the same time to avoid a Python loop over the PDFs. This will 
be supported by specifying the `axis` argument:

.. code::

    cdf_sampler = InverseCDFSampler(pdf=pdfs, axis=0)
    samples = cdf_sampler.sample(size=1)


The `InverseCDFSampler` could possibly implement a few helper functions to plot 
the CDF or PDF. The `InverseCDFSampler` class will replace the current 
`GeneralRandom` and `GeneralRandomArray` classes in `gammapy.utils.distributions`. 
Possibly the `InverseCDFSampler` needs to support transforming PDFs e.g. log 
transformations of power-laws to maintain accuracy. The need for this is unclear.


MapEventSampler
===============

To support sampling from the predicted number of counts maps for source as well 
as background maps, we propose to introduce a `MapEventSampler` class. The 
responsibility of this class is to handle the physical coordinate transformations, 
time dependence of the model, output data structures and sampling of the total 
number of observed events. We note that this class does not scatter the events
within each bin but it places them at the bin center. This may results in artifacts
in the analysis when adopting a different binning. However, once the PSF is applied, 
this is no more an issue as the event positions will be randomly scattered.

Starting from a predicted number of counts map (e.g. computed by the `MapEvaluator`):

.. code::

    src = SkyModel()
    evaluator = MapEvaluator(src, exposure, psf=None, edisp=None)
    npred_map = evaluator.compute_npred()

The `MapEventSampler` takes this map and a lightcurve model as an input and 
allows to sample from it with the `.sample()` method:

.. code::

    lightcurve = LightCurveTableModel() # or PhaseCurveTableModel()
    src_sampler = MapEventSampler(npred_map, lightcurve, t_min=, t_max=)

    # draw total number of events
    n_events = src_sampler.npred_total()

    # draw events as an astropy table
    events_src = map_sampler.sample()

If no lightcurve is provided a constant rate can be assumed e.g. for 
background models:

.. code::

    bkg_map = BackgroundModel().map
    bkg_sampler = MapEventSampler(bkg_map, t_min=, t_max=)
    events_bkg = bkg_sample.sample()



IRFEventDistibutor
=================

We also propose a class to handle correctly the spatially varying IRFs, we suggest
to introduce an `IRFEventDistibutor` class. Based on the `PSFMap` and `EDispMap` 
as an input it interpolates the "correct" IRF at the position of a given event and
applies it. In more detail the class will calculate the psf and the energy dispersion 
for each event true position and true energy. The reconstructed energies and 
positions are then appended to the event list. The IRFs are assumed to be constant
and not time-dependent. The time dependency will be handled higher level, by a loop
over good time-intervals. The class would be used as following:

.. code::

    events = vstack([events_src_1, events_src_2, ..., events_src_N])
    event_distributor = IRFEventDistibutor(psf_map, edisp_map)

    events = irf_distributor.sample_psf(events)
    events = irf_distributor.sample_edisp(events)

Alternatively the IRFs could be applied per model component and be handled in 
the `MapEventSampler`. However in this case the IRFs would not be applied 
correctly for e.g. very extended sources, because the IRF changes over region 
of the source. If we find the approach with the `IRFEventDistibutor` to be not 
performant enough or problematic in memory use, it can be still used as a 
simple fallback solution.


MapDatasetEventSampler
=======================

To combine the `MapEventSampler` and `IRFEventDistibutor` objects we finally propose 
to introduce a `MapDatasetEventSampler`, which executes the sampling from all 
source components, applies the IRFs, samples from the background model and 
returns a stacked, combined event list.

This is the proposed high level API:

.. code::
    
    dataset_sampler = MapDatasetEventSampler(dataset)
    events = dataset_sampler.sample()

This requires to add `t_min` and `t_max` information to `MapDataset` or maybe a 
`MapDataset.gti` attribute, defining the GTI for the given dataset. In addition 
it also requires to add a lightcurve model to the `SkyModel`.

More detailed:

.. code::

    events = []

    # sample from source components
    for evaluator in dataset._evaluators:
        evaluator.psf = None?
        evaluator.edisp = None?
        npred = evaluator.compute_npred()

        sampler = MapEventSampler(npred)

        # set an ID for the source component?
        
        events.append(sampler.sample())

    events_stacked = vstack(events)

    # apply IRFs
    irf_sampler = IRFSampler(events_stacked, dataset.psf_map, dataset.edisp_map)
    events_reco = irf_sampler.sample()

    # sample from background
    bkg_sampler = MapEventSampler(dataset.background_model.map)
    events_bkg = bkg_sampler.sample()

    events_total = vstack([events_reco, event_bkg])


Convenience API
===============
---ADD a few more words about the possibility that the users do not to import a IRF
class but they can directly use the `MapEventSampler'.---
Additional methods to the `MapEventSampler' can be included to take into account
the PSF and Edisp corrections. This may be done as follows:

- `events_src = MapEvaluator.sample()` to sample from a source model
- `events = EdispMapDistributor.sample(events=)` to apply the energy dispersion
- `events = PsfMapDistributor.sample(events=)` to apply the PSF
- `events = MapDataset.sample()` to combine all together.

This has the advantage of a smaller API but, for more than one simulated source,
it needs the use a cycles.

It remains to answer the question what to do when the source lightcurve is 
shorter than the total exposure time: do we repeat the temporal information 
or do we just consider the remaining time as a flat lightcurve?


Simulating multiple observations
================================
The question of simulating mutiple observations from e.g. an `ObservationTable` 
or `GTI` object as it is needed for simulating data for the CTA data challenge 
is not addressed in this PIG.


List of proposed pull requests
==============================

This is a proposal for a list of pull requests implementing the proposed changes, 
ordered by priority:

1. Rename `gammapy.utils.distributions' to `gammapy.utils.random' and move the 
   current `gammapy.utils.random' there (v0.12).
2. Remove the currently unused `GeneralRandomArray` class (v0.12)
3. Implement the InverseCDFSampler in `gammapy.utils.random' in `inverse_cdf.py' 
   and add tests.
4. Remove the current `GeneralRandom` class and adapt `gammapy.astro.population.simulate' 
   accordingly.
5. Implement `MapEventSampler` class into `gammapy.utils.random' and named it 
   `map_evesampler.py' and include some tests. (v0.13)
6. Add tutorial on how to use the `MapEventSampler' applying it to both sources and background.
7. Implement `IRFEventDistibutor' into `gammapy.utils.random' with the name `event_distributor.py'
   and add some tests. (v0.13)
8. Implement `MapDatasetEventSampler' into `gammapy.utils.random' and add some tests. (v0.13 or v0.14)
9. Add tutorial for event simulations of different kinds of sources. (v0.13 or v0.14)


Decision
========



.. _Prototype: https://github.com/fabiopintore/notebooks-public/blob/master/gammapy-event-sampling/prototype.ipynb
.. _inverseCDF: https://en.wikipedia.org/wiki/Inverse_transform_sampling
.. _here: https://stackoverflow.com/questions/21100716/fast-arbitrary-distribution-random-sampling/21101584#21101584
.. _gammalib: http://cta.irap.omp.eu/gammalib/doxygen/GModelSpatialRadialGauss_8cpp_source.html#l00325
.. _spec: https://docs.gammapy.org/0.11/api/gammapy.spectrum.SpectrumSimulation.html
.. _three-D: https://docs.gammapy.org/0.11/notebooks/simulate_3d.html
.. _astrisim: http://www.iasf-milano.inaf.it/~giuliani/astrisim/

